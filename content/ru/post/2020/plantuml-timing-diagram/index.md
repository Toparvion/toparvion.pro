---
title: "Plantuml Timing Diagram"
subtitle: ""
summary: ""
authors: []
tags: []
categories: []
date: 2020-02-22T07:49:05+07:00
lastmod: 2020-02-22T07:49:05+07:00
featured: false
draft: true

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Focal points: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight.
image:
  caption: ""
  focal_point: ""
  preview_only: false

# Projects (optional).
#   Associate this post with one or more of your projects.
#   Simply enter your project's folder or file name without extension.
#   E.g. `projects = ["internal-project"]` references `content/project/deep-learning/index.md`.
#   Otherwise, set `projects = []`.
projects: []
---

Когда речь заходит о проблемах взаимодействия приложения с реляционной СУБД, чаще всего в голову приходят 2 причины: неоптимальные запросы и долгое установление JDBC-соединений. Для первой придумали массу решений: от хинтов в SQL до смены СУБД на более подходящую. Для второй решение, в основном, одно – пул коннектов (например, Hikari), который заранее открывает нужное количество коннектов к БД и удерживает их “прогретыми”, выдавая приложению по необходимости. И хотя пулы давно стали де-факто стандартом в промышленных приложениях и отлично решают свою задачу, они никак не страхуют от нерационального использования коннектов самим приложением: оно по-прежнему может легко исчерпать пул, если будет активно запрашивать коннекты и подолгу их не возвращать.

Как раз с такую проблему я встретил в своём рабочем проекте. Большое монолитное веб-приложение с кучей асинхронных подзадач обращалось к пулу сотни раз в секунду (даже на тесте). Из мониторингов были только графики числа занятых и свободных коннектов, но они здесь бесполезны. Как понять в чем причина?

Поскольку любой пул содержит относительно небольшое число коннектов (по ресурсам это довольно “дорогие” объекты), он предполагает, что требующие похода в БД компоненты будут брать коннекты на максимально короткий срок. Иначе быстро настанет момент, когда очередной компонент запросит себе коннект у пула и либо замрёт в ожидании, либо получит отказ, потому что прямо сейчас свободных коннектов уже нет. И в том, и в другом случае для конечных пользователей это плохо: приложение начинает либо “тупить”, либо отвечать 500-ми ошибками.

*(вставить график исчерпания коннектов в Ядре 25.12.19)*

Однако в сложном приложении…